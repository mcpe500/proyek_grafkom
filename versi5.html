<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Render .glb with Three.js</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      .hide-cursor {
        cursor: none;
      }
    </style>
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script>
      var scene, renderer, controls, camera;
      var moveForward = false;
      var moveBackward = false;
      var moveLeft = false;
      var moveRight = false;

      var raycaster = new THREE.Raycaster();
      var downRay = new THREE.Vector3(0, -0.1, 0);
      var previousPosition = new THREE.Vector3();
      var cameraOffset = new THREE.Vector3(-10, 5, 0);

      var clouds = [];
      var objects = [];
      var eagleEyeMode = false;

      var harversterState = false;
      var harvester_position = { x: 10, y: 0.1, z: 40 };
      var harvesterPosition = new THREE.Vector3();
      var harvesterRotation = new THREE.Euler(0, -Math.PI, 0);

      var sunAngle = 0;
      var maxSunAngle = Math.PI;
      var sunLightColor = 0xffffcc;
      var moonLightColor = 0xeeeeee;
      var sunLight = new THREE.DirectionalLight(0xffffff, 0.5);
      var moonLight = new THREE.DirectionalLight(0xffffff, 0.5);
      var hemisphereDay = new THREE.HemisphereLight(0xffffff, 0.5);

      var ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      var shadowSize = 150;
      var orbitRadius = 150;
      var dayNightCycle = 0;

      var eagleEyeCameraPosition = new THREE.Vector3(
        harvester_position.x,
        harvester_position.y + 5,
        harvester_position.z
      );
      var eagleEyeCameraLookAt = new THREE.Vector3(
        harvester_position.x,
        harvester_position.y,
        harvester_position.z
      );
      var firstPersonCameraPosition = new THREE.Vector3();
      var firstPersonCameraRotation = new THREE.Euler();
      var loader = new THREE.GLTFLoader();

      function switchToFirstPersonMode() {
        camera.position.copy(firstPersonCameraPosition);
        camera.rotation.copy(firstPersonCameraRotation);
      }

      function switchToEagleEyeMode() {
        firstPersonCameraPosition.copy(camera.position);
        firstPersonCameraRotation.copy(camera.rotation);

        camera.position.copy(eagleEyeCameraPosition);
        camera.lookAt(eagleEyeCameraLookAt);
      }

      function addObjectToCheck(object, objectFile) {
        objects.push(object);
        objects[objects.length - 1].sName = objectFile;
      }

      function loadObject(objectFile, x, y, z, scale, options = {}) {
        loader.load(objectFile, function (gltf) {
          var object = gltf.scene;
          object.position.set(x, y, z);
          object.scale.set(scale, scale, scale);
          object.traverse(function (node) {
            if (node.isMesh) {
              node.receiveShadow = true;
              node.castShadow = true;
            }
          });
          if (options) {
            if (options.rotation) {
              object.rotation.x = THREE.MathUtils.degToRad(options.rotation.x);
              object.rotation.y = THREE.MathUtils.degToRad(options.rotation.y);
              object.rotation.z = THREE.MathUtils.degToRad(options.rotation.z);
            }
            if (options.center) {
              object.position.x += options.center.x;
              object.position.y += options.center.y;
              object.position.z += options.center.z;
            }
          }
          scene.add(object);
          addObjectToCheck(object, objectFile);
        });
      }

      function rotate(object, { x = 0, y = 0, z = 0 } = {}) {
        if (object === undefined) return;
        const { degToRad } = THREE.MathUtils;
        object.rotation.x += degToRad(x);
        object.rotation.y += degToRad(y);
        object.rotation.z += degToRad(z);
      }

      async function makeWalls(objectFile, startX, startZ, w, h) {
        const width = w + 1;
        const height = h + 1;
        const spacing = 5 * 0.975;
        const positionsAndRotations = [];

        for (let i = 2; i < width; i++) {
          positionsAndRotations.push({
            position: [startX + i * spacing, 0.75, startZ],
            rotation: { x: 0, y: 90, z: 0 },
          });
        }
        for (let i = 0; i < width - 1; i++) {
          positionsAndRotations.push({
            position: [
              startX + i * spacing,
              0.75,
              startZ + (height - 1) * spacing,
            ],
            rotation: { x: 0, y: 270, z: 0 },
          });
        }
        for (let i = 1; i < height - 1; i++) {
          positionsAndRotations.push({
            position: [startX, 0.75, startZ + i * spacing],
            rotation: { x: 0, y: 180, z: 0 },
          });
        }
        for (let i = 1; i < height; i++) {
          positionsAndRotations.push({
            position: [
              startX + (width - 1) * spacing,
              0.75,
              startZ + i * spacing,
            ],
            rotation: { x: 0, y: 0, z: 0 },
          });
        }

        for (const { position, rotation } of positionsAndRotations) {
          loader.load(
            objectFile,
            (gltf) => {
              const object = gltf.scene;
              object.position.set(...position);
              object.scale.set(1, 1, 1);
              object.traverse(function (node) {
                if (node.isMesh) {
                  node.receiveShadow = true;
                  node.castShadow = true;
                }
              });
              if (rotation) {
                object.rotation.x = THREE.MathUtils.degToRad(rotation.x);
                object.rotation.y = THREE.MathUtils.degToRad(rotation.y);
                object.rotation.z = THREE.MathUtils.degToRad(rotation.z);
              }
              scene.add(object);
              addObjectToCheck(object, objectFile);
            },
            undefined,
            (error) => console.error(`Failed to load object: ${error}`)
          );
        }
      }

      async function makeWheats(objectFile, startX, startZ, w, h) {
        const width = w + 1;
        const height = h + 1;
        const spacing = 5 * 0.975;
        const positionsAndRotations = [];

        for (let i = 2; i < width; i++) {
          positionsAndRotations.push({
            position: [startX + i * spacing, 0.75, startZ],
            rotation: { x: 0, y: 90, z: 0 },
          });
        }
        for (let i = 0; i < width - 1; i++) {
          positionsAndRotations.push({
            position: [
              startX + i * spacing,
              0.75,
              startZ + (height - 1) * spacing,
            ],
            rotation: { x: 0, y: 270, z: 0 },
          });
        }
        for (let i = 1; i < height - 1; i++) {
          positionsAndRotations.push({
            position: [startX, 0.75, startZ + i * spacing],
            rotation: { x: 0, y: 180, z: 0 },
          });
        }
        for (let i = 1; i < height; i++) {
          positionsAndRotations.push({
            position: [
              startX + (width - 1) * spacing,
              0.75,
              startZ + i * spacing,
            ],
            rotation: { x: 0, y: 0, z: 0 },
          });
        }

        for (const { position, rotation } of positionsAndRotations) {
          loader.load(
            objectFile,
            (gltf) => {
              const object = gltf.scene;
              object.position.set(...position);
              object.scale.set(25, 25, 25);
              object.traverse(function (node) {
                if (node.isMesh) {
                  node.receiveShadow = true;
                  node.castShadow = true;
                }
              });
              if (rotation) {
                object.rotation.x = THREE.MathUtils.degToRad(rotation.x);
                object.rotation.y = THREE.MathUtils.degToRad(rotation.y);
                object.rotation.z = THREE.MathUtils.degToRad(rotation.z);
              }
              scene.add(object);
              addObjectToCheck(object, objectFile);
            },
            undefined,
            (error) => console.error(`Failed to load object: ${error}`)
          );
        }
      }
      function init() {
        scene = new THREE.Scene();
        renderer = new THREE.WebGLRenderer();
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        renderer.setSize(window.innerWidth, window.innerHeight);

        scene.add(hemisphereDay);

        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.top += shadowSize;
        sunLight.shadow.camera.bottom -= shadowSize;
        sunLight.shadow.camera.left -= shadowSize;
        sunLight.shadow.camera.right += shadowSize;
        scene.add(sunLight);
        scene.add(new THREE.CameraHelper(sunLight.shadow.camera));

        moonLight.castShadow = true;
        moonLight.shadow.mapSize.width = 2048;
        moonLight.shadow.mapSize.height = 2048;
        moonLight.shadow.camera.top += shadowSize;
        moonLight.shadow.camera.bottom -= shadowSize;
        moonLight.shadow.camera.left -= shadowSize;
        moonLight.shadow.camera.right += shadowSize;
        scene.add(moonLight);
        scene.add(new THREE.CameraHelper(moonLight.shadow.camera));

        const windmill_location = { x: 20, y: 0, z: 10 };
        loadObject(
          "./textures/result/kaki_windmill.glb",
          windmill_location.x,
          windmill_location.y,
          windmill_location.z,
          0.05,
          {
            rotation: { x: 90, y: 0, z: 0 },
          }
        );
        loadObject(
          "./textures/result/baling_baling_windmill.glb",
          windmill_location.x + 1.2,
          windmill_location.y + 28.5,
          windmill_location.z * 1,
          0.05,
          {
            center: {
              x: 0,
              y: 0,
              z: 0,
            },
          }
        );

        makeWalls("./textures/wooden_fence.glb", -30, -30, 15, 15);
        makeWheats("./textures/wheat.glb", -30, -30, 15, 15);
        loadObject("./textures/barn.glb", -10, 2.8, 30, 1);
        loadObject("./textures/scarecrow.glb", 10, 0, 10, 1);
        // for (let i = 0; i < 10; i++) {
        //   for (let j = 0; j < 10; j++) {
        //     loadObject("./textures/wheat.glb", 40, 0, -26, 25);
        //   }
        // }
        loadObject(
          "./textures/result/harvester.glb",
          harvester_position.x,
          harvester_position.y,
          harvester_position.z,
          1
        );

        var cloudFiles = [
          "./textures/cloud_1.glb",
          "./textures/cloud_2.glb",
          "./textures/cloud_3.glb",
          "./textures/cloud_4.glb",
        ];
        function loadCloud(cloudFile, x, y, z) {
          loader.load(cloudFile, function (gltf) {
            var cloud = gltf.scene;
            cloud.receiveShadow = false;
            cloud.position.set(x, y, z);
            cloud.scale.set(5, 5, 5);
            cloud.traverse(function (node) {
              if (node.isMesh) {
                node.castShadow = true;
              }
            });
            scene.add(cloud);
            clouds.push(cloud);
          });
        }
        var cloudGroup = new THREE.Group();
        for (var i = 0; i < 30; i++) {
          for (var j = 0; j < cloudFiles.length; j++) {
            var x = Math.random() * 500 - 200;
            var y = Math.random() * 20 + 30;
            var z = Math.random() * 500 - 200;
            loadCloud(cloudFiles[j], x, y, z);
          }
        }
        scene.add(cloudGroup);
        cloudGroup.add(ambientLight);

        var floorGeometry = new THREE.PlaneGeometry(250, 250);
        var floorMaterial = new THREE.MeshStandardMaterial({ color: 0x996633 });
        var floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.receiveShadow = true;
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(0, 0, 0);
        scene.add(floor);

        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 50, 190);

        camera = new THREE.PerspectiveCamera(
          50,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.y = 20;

        controls = new THREE.PointerLockControls(camera, document.body);
        scene.add(controls.getObject());

        var onMouseDown = function (event) {
          controls.lock();
        };

        var onPointerLockChange = function () {
          controls.enabled = document.pointerLockElement === document.body;
        };

        function enterHarvester() {
          // calculate distance between harvester and the current camera/player
          const harverster = objects.find((o) => o.sName.includes("harvester"));
          const distance = camera.position.distanceTo(harverster.position);
          if (harversterState == false && distance < 5) {
            eagleEyeMode = true;
            switchToEagleEyeMode();
            harversterState = true;

            camera.position.x = harverster.position.x + 10;
            camera.position.y = 5;
            camera.position.z = harverster.position.z;

            camera.lookAt(harverster.position);
            // harvesterPosition.copy(harvester.position);
            // harvesterRotation.copy(harvester.rotation);
          } else if (harversterState == true) {
            eagleEyeMode = false;
            switchToFirstPersonMode();
            camera.position.x = harverster.position.x + 2;
            camera.position.y = 5;
            camera.position.z = harverster.position.z + 2;
            harversterState = false;
          }
        }
        var onKeyDown = function (event) {
          switch (event.keyCode) {
            case 87: // W
              moveForward = true;
              break;
            case 65: // A
              moveLeft = true;
              break;
            case 83: // S
              moveBackward = true;
              break;
            case 68: // D
              moveRight = true;
              break;
            case 69: // E buat enter tractor/harverset
              enterHarvester();
              break;
          }
        };

        var onKeyUp = function (event) {
          switch (event.keyCode) {
            case 87: // W
              moveForward = false;
              break;
            case 65: // A
              moveLeft = false;
              break;
            case 83: // S
              moveBackward = false;
              break;
            case 68: // D
              moveRight = false;
              break;
          }
        };

        window.addEventListener("mousedown", onMouseDown, false);
        document.addEventListener(
          "pointerlockchange",
          onPointerLockChange,
          false
        );
        window.addEventListener("keydown", onKeyDown, false);
        window.addEventListener("keyup", onKeyUp, false);
      }

      function checkCollision() {
        var raycasters = [];
        raycasters.push(
          new THREE.Raycaster(
            controls.getObject().position,
            new THREE.Vector3(0, 0, -1)
          )
        );
        raycasters.push(
          new THREE.Raycaster(
            controls.getObject().position,
            new THREE.Vector3(0, 0, 1)
          )
        );
        raycasters.push(
          new THREE.Raycaster(
            controls.getObject().position,
            new THREE.Vector3(-1, 0, 0)
          )
        );
        raycasters.push(
          new THREE.Raycaster(
            controls.getObject().position,
            new THREE.Vector3(1, 0, 0)
          )
        );
        var intersected = false;
        raycasters.forEach(function (raycaster) {
          var intersects = raycaster.intersectObjects(objects, true);
          if (intersects.length > 0 && intersects[0].distance < 1) {
            intersected = true;
          }
        });
        if (intersected) {
          controls.getObject().position.copy(previousPosition);
        } else {
          previousPosition.copy(controls.getObject().position);
        }
      }

      function animate() {
        requestAnimationFrame(animate);

        var baling_baling_windmill = objects.find((o) =>
          o.sName.includes("baling_baling_windmill")
        );
        rotate(baling_baling_windmill, { x: 1, y: 0, z: 0 });

        if (sunAngle < maxSunAngle) {
          sunAngle += 0.01;
        } else {
          sunAngle = 0;
          dayNightCycle = (dayNightCycle + 1) % 2;
        }

        sunLight.position.x = Math.cos(sunAngle) * orbitRadius;
        sunLight.position.y = Math.sin(sunAngle) * orbitRadius;
        sunLight.position.z = 0;

        hemisphereDay.position.x = Math.cos(sunAngle) * orbitRadius;
        hemisphereDay.position.y = Math.sin(sunAngle) * orbitRadius;
        hemisphereDay.position.z = 0;

        moonLight.position.x = Math.cos(sunAngle) * orbitRadius;
        moonLight.position.y = Math.sin(sunAngle) * orbitRadius;
        moonLight.position.z = 0;

        var skyColor;
        var sunriseColor = new THREE.Color(0.8, 0.6, 0.2);
        var morningColor = new THREE.Color(0.2, 0.6, 0.8);
        var noonColor = new THREE.Color(0.4, 0.8, 1.0);
        var eveningColor = new THREE.Color(0.8, 0.4, 0.2);
        var sunsetColor = new THREE.Color(0.6, 0.3, 0.1);
        var nightColor = new THREE.Color(0.05, 0.05, 0.2);

        var transitionProgress = sunAngle / maxSunAngle;
        if (dayNightCycle === 0) {
          if (transitionProgress < 0.25) {
            skyColor = sunriseColor.lerp(
              morningColor,
              transitionProgress / 0.25
            );
            sunLight.intensity = (transitionProgress / 0.25) * 0.5;
            moonLight.intensity = 0.5 - (transitionProgress / 0.25) * 0.5;
            hemisphereDay.intensity = (transitionProgress / 0.25) * 0.5;
          } else if (transitionProgress < 0.5) {
            skyColor = morningColor.lerp(
              noonColor,
              (transitionProgress - 0.25) / 0.25
            );
          } else if (transitionProgress < 0.75) {
            skyColor = noonColor.lerp(
              eveningColor,
              (transitionProgress - 0.5) / 0.25
            );
          } else {
            skyColor = eveningColor.lerp(
              sunsetColor,
              (transitionProgress - 0.75) / 0.25
            );
            moonLight.intensity = ((transitionProgress - 0.75) / 0.25) * 0.25;
            hemisphereDay.intensity =
              0.5 - ((transitionProgress - 0.75) / 0.25) * 0.5;
          }
        } else {
          if (transitionProgress < 0.1) {
            skyColor = sunsetColor.lerp(nightColor, transitionProgress / 0.1);
            moonLight.intensity = (transitionProgress / 0.1) * 0.25;
            sunLight.intensity = 0.5 - (transitionProgress / 0.1) * 0.5;
          } else if (transitionProgress < 0.9) {
            skyColor = nightColor;
          } else {
            skyColor = nightColor.lerp(
              sunriseColor,
              (transitionProgress - 0.9) / 0.1
            );
          }
        }
        scene.background = skyColor;

        var moveSpeed = 0.2;
        var moveVector = new THREE.Vector3();
        controls.getObject().getWorldDirection(moveVector);
        moveVector.y = 0;
        moveVector.normalize();

        if (!eagleEyeMode) {
          raycaster.set(controls.getObject().position, downRay);
          var intersects = raycaster.intersectObjects(scene.children, true);

          if (intersects.length > 0) {
            if (intersects[0].distance - 1.5 > 0) {
              controls.getObject().position.y -= 0.6;
            }
          }
        }

        checkCollision();
        for (var i = 0; i < clouds.length; i++) {
          clouds[i].position.x -= 0.1;

          if (clouds[i].position.x < -300) {
            clouds[i].position.x = 300;
            clouds[i].position.y = Math.random() * 20 + 30;
            clouds[i].position.z = Math.random() * 500 - 200;
          }
        }
        if (harversterState) {
          const harvester = objects.find((o) => o.sName.includes("harvester"));
          if (moveForward) {
            controls
              .getObject()
              .position.add(moveVector.clone().multiplyScalar(moveSpeed));
          }
          if (moveBackward) {
            controls
              .getObject()
              .position.sub(moveVector.clone().multiplyScalar(moveSpeed));
          }
          if (moveLeft) {
            controls
              .getObject()
              .position.add(
                moveVector
                  .clone()
                  .cross(controls.getObject().up)
                  .negate()
                  .multiplyScalar(moveSpeed)
              );
          }
          if (moveRight) {
            controls
              .getObject()
              .position.add(
                moveVector
                  .clone()
                  .cross(controls.getObject().up)
                  .multiplyScalar(moveSpeed)
              );
          }
          // moveVector.applyEuler(harvester.rotation)
          harvester.position.x = camera.position.x - 10;
          harvester.position.y = 0;
          harvester.position.z = camera.position.z;

          // harvester.rotation.x = camera.rotation.x;
          harvester.rotation.y = camera.rotation.y;
          // harvester.rotation.z = camera.rotation.z;
          // var moveSpeed = 0.2;
          // var moveVector = new THREE.Vector3();
          // const harvester = objects.find((o) => o.sName.includes("harvester"));
          // if (moveForward) {
          //   controls
          //     .getObject()
          //     .position.add(moveVector.clone().multiplyScalar(moveSpeed));
          //   harvester.position.x = camera.position.x;
          //   harvester.position.y = 0;
          //   harvester.position.z = camera.position.z;
          //   console.log("Moving forward");
          // }
          // if (moveBackward) {
          //   console.log("Moving backward");
          // }
          // if (moveLeft) {
          //   console.log("Moving left");
          // }
          // if (moveRight) {
          //   console.log("Moving right");
          // }
          // if (moveForward) {
          // moveVector.set(0, 0, -moveSpeed);
          // moveVector.applyEuler(harvesterRotation);
          // harvesterPosition.add(moveVector);
          // }
          // if (moveBackward) {
          //   moveVector.set(0, 0, moveSpeed);
          //   moveVector.applyEuler(harvesterRotation);
          //   harvesterPosition.add(moveVector);
          // }
          // if (moveLeft) {
          //   moveVector.set(-moveSpeed, 0, 0);
          //   moveVector.applyEuler(harvesterRotation);
          //   harvesterPosition.add(moveVector);
          // }
          // if (moveRight) {
          //   moveVector.set(moveSpeed, 0, 0);
          //   moveVector.applyEuler(harvesterRotation);
          //   harvesterPosition.add(moveVector);
          // }

          // harvester.position.copy(harvesterPosition);
          // var cameraOffset = new THREE.Vector3(-10, 5, 0);
          // harvester.position.x = camera.position.x + 10;
          // harvester.position.y = camera.position.y - 5;
          // harvester.position.z = camera.position.z - 0;

          // camera.position.x = harvester.position.x - 10;
          // camera.position.y = harvester.position.y + 5;
          // camera.position.z = harvester.position.z + 0;

          // // harvester.rotation.copy(harvesterRotation);
          // // harvester.rotation.x = 90;
          // harvester.rotation.y = camera.rotation.y;
          // harvester.rotation.z = 90;

          // cameraOffset.applyEuler(harvesterRotation);
          // const rotatedOffset = cameraOffset
          //   .clone()
          //   .applyEuler(harvester.rotation);
          // camera.position.copy(harvesterPosition).add(rotatedOffset);
          // camera.lookAt(harvesterPosition);
        } else {
          if (moveForward)
            controls
              .getObject()
              .position.add(moveVector.clone().multiplyScalar(moveSpeed));
          if (moveBackward)
            controls
              .getObject()
              .position.sub(moveVector.clone().multiplyScalar(moveSpeed));
          if (moveLeft)
            controls
              .getObject()
              .position.add(
                moveVector
                  .clone()
                  .cross(controls.getObject().up)
                  .negate()
                  .multiplyScalar(moveSpeed)
              );
          if (moveRight)
            controls
              .getObject()
              .position.add(
                moveVector
                  .clone()
                  .cross(controls.getObject().up)
                  .multiplyScalar(moveSpeed)
              );
        }

        renderer.render(scene, camera);
      }

      init();
      animate();
    </script>
  </body>
</html>
